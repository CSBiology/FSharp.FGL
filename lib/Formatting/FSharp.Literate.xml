<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.Literate</name></assembly>
<members>
<member name="T:FSharp.Collections.Tree`1">
<summary>
 Represents a tree with nodes containing values an a list of children

 [omit]
</summary>
</member>
<member name="M:FSharp.Collections.Tree.ofIndentedList``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Int32,``0}})">
<summary>
 Turns a list of items with an indentation specified by an integer
 into a tree where indented items are children.
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeDeeperThan``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes elements that are deeper (children) and turns them into nodes
</summary>
</member>
<member name="M:FSharp.Collections.Tree.takeAtLevel``2(``0,Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})">
<summary>
 Takes all elements at the specified level and turns them into nodes
</summary>
</member>
<member name="T:FSharp.Collections.Tree">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharp.Collections.List.nestUnderLastMatching``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 A function that nests items of the input sequence 
 that do not match a specified predicate under the 
 last item that matches the predicate. 
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntilEquals``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions the input list into two parts - the break is added 
 at a point where the list starts with the specified sub-list.
</summary>
</member>
<member name="M:FSharp.Collections.List.startsWith``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Tests whether a list starts with the elements of another
 list (specified as the first parameter)
</summary>
</member>
<member name="M:FSharp.Collections.List.iterInterleaved``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Iterates over the elements of the list and calls the first function for 
 every element. Between each two elements, the second function is called.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntilLookahead``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns &apos;false&apos;) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionUntil``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns &apos;false&apos;) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhileLookahead``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``0},System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the specified predicate 
 returns true) and a rest of the list. The predicate gets the entire 
 tail of the list and can perform lookahead.
</summary>
</member>
<member name="M:FSharp.Collections.List.partitionWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Partitions list into an initial sequence (while the 
 specified predicate returns true) and a rest of the list.
</summary>
</member>
<member name="M:FSharp.Collections.List.skipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Skips elements while the predicate returns &apos;true&apos; and then 
 returns the rest of the list as a result.
</summary>
</member>
<member name="M:FSharp.Collections.List.skip``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Skips the specified number of elements. Fails if the list is smaller.
</summary>
</member>
<member name="M:FSharp.Collections.List.singleton``1(``0)">
<summary>
 Returns a singleton list containing a specified value
</summary>
</member>
<member name="T:FSharp.Collections.List">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharp.Patterns.|Command|_|``2(``0,System.Collections.Generic.IDictionary{``0,``1})">
<summary>
 Lookup in a dictionary
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommand|_|(System.String)">
<summary>
 Utility for parsing commands - this deals with a single command.
 The key of the command should be identifier with just 
 characters in it - otherwise, the parsing fails.
</summary>
</member>
<member name="M:FSharp.Patterns.|ParseCommands|_|(System.String)">
<summary>
 Utility for parsing commands. Commands can be used in different places. We 
 recognize `key1=value, key2=value` and also `key1:value, key2:value`
 The key of the command should be identifier with just 
 characters in it - otherwise, the parsing fails.
</summary>
</member>
<member name="M:FSharp.Patterns.|Let|``2(``0,``1)">
<summary>
 Parameterized pattern that assigns the specified value to the 
 first component of a tuple. Usage:

    match str with
    | Let 1 (n, &quot;one&quot;) | Let 2 (n, &quot;two&quot;) -&gt; n
 
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TrimParagraphLines|(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Formatting.Common.MarkdownRange}})">
<summary>
 Trims all lines of the current paragraph
</summary>
</member>
<member name="P:FSharp.Patterns.Lines.|TrimBlankStart|">
<summary>
 Removes whitespace lines from the beginning of the list
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TakeCodeBlock|_|(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,FSharp.Formatting.Common.MarkdownRange}})">
<summary>
 Matches when there are some lines at the beginning that are
 either empty (or whitespace) or start with at least 4 spaces (a tab counts as 4 spaces here).
 Returns all such lines from the beginning until a different line and
 the number of spaces the first line started with.
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TakeStartingWithOrBlank|_|(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Matches when there are some lines at the beginning that are 
 either empty (or whitespace) or start with the specified string.
 Returns all such lines from the beginning until a different line.
</summary>
</member>
<member name="M:FSharp.Patterns.Lines.|TrimBlank|``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,``0}})">
<summary>
 Removes blank lines from the start and the end of a list
</summary>
</member>
<member name="M:FSharp.Patterns.List.|AsString|(Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Returns a list of characters as a string.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|BracketDelimited|_|(System.Char,System.Char,Microsoft.FSharp.Collections.FSharpList{System.Char})">
<summary>
 Matches a list if it starts with a bracketed list. Nested brackets
 are skipped (by counting opening and closing brackets) and can be 
 escaped using the &apos;\&apos; symbol.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|Delimited|_|``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiter. Returns a wrapped list and the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|StartsWith|_|``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list. Returns the list.
</summary>
</member>
<member name="M:FSharp.Patterns.List.|DelimitedWith|_|``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Matches a list if it starts with a sub-list that is delimited
 using the specified delimiters. Returns a wrapped list and the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|EqualsRepeated|_|(System.String,FSharp.Formatting.Common.MarkdownRange,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string consists of some number of 
 complete repetitions of a specified sub-string.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithWrapped|_|(System.String,System.String,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with a sub-string wrapped using the 
 opening and closing sub-string specified in the parameter.
 For example &quot;[aa]bc&quot; is wrapped in [ and ] pair. Returns the wrapped
 text together with the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithRepeated|_|(System.String,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with a non-zero number of complete
 repetitions of the specified parameter (and returns the number
 of repetitions, together with the rest of the string)

    let (StartsWithRepeated &quot;/\&quot; (2, &quot; abc&quot;)) = &quot;/\/\ abc&quot;

</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsAndEndsWithTrim|_|(System.String,System.String,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns trimmed body)
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsAndEndsWith|_|(System.String,System.String,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns the rest of it)
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithNTimesTrimIgnoreStartWhitespace|_|(System.String,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with the specified sub-string (ignoring whitespace at the start)
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithTrim|_|(System.String,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with the specified sub-string
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWith|_|(System.String,System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with the specified sub-string
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|StartsWithAny|_|(System.Collections.Generic.IEnumerable{System.String},System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string starts with any of the specified sub-strings
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimStartAndCount|(System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Returns a string trimmed from the start together with 
 the number of skipped whitespace characters
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimEndUsing|(System.Collections.Generic.IEnumerable{System.Char},System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Returns a string trimmed from the end using characters given as a parameter
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimStart|(System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Returns a string trimmed from the start
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimEnd|(System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Returns a string trimmed from the end
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|TrimBoth|(System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Returns a string trimmed from both start and end
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|Unindented|_|(System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string does starts with non-whitespace
</summary>
</member>
<member name="M:FSharp.Patterns.StringPosition.|WhiteSpace|_|(System.String,FSharp.Formatting.Common.MarkdownRange)">
<summary>
 Matches when a string is a whitespace or null
</summary>
</member>
<member name="M:FSharp.Patterns.String.removeSpaces(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Given a list of lines indented with certan number of whitespace 
 characters (spaces), remove the spaces from the beginning of each line 
 and return the string as a list of lines
</summary>
</member>
<member name="M:FSharp.Patterns.String.|SkipSingleLine|(System.String)">
<summary>
 Ignores everything until a end-line character is detected, returns the remaining string.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithWrapped|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with a sub-string wrapped using the 
 opening and closing sub-string specified in the parameter.
 For example &quot;[aa]bc&quot; is wrapped in [ and ] pair. Returns the wrapped
 text together with the rest.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWithTrim|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns trimmed body)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsAndEndsWith|_|(System.String,System.String,System.String)">
<summary>
 Matches when a string starts with the given value and ends 
 with a given value (and returns the rest of it)
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWithTrim|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
 The matched string is trimmed from all whitespace.
</summary>
</member>
<member name="M:FSharp.Patterns.String.|StartsWith|_|(System.String,System.String)">
<summary>
 Matches when a string starts with the specified sub-string
</summary>
</member>
<member name="M:FSharp.Patterns.String.|TrimBoth|(System.String)">
<summary>
 Returns a string trimmed from both start and end
</summary>
</member>
<member name="M:FSharp.Patterns.String.|WhiteSpace|_|(System.String)">
<summary>
 Matches when a string is a whitespace or null
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.SourceFile">
<summary>
 Location where the file was loaded from
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.Source">
<summary>
 Original document source code
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.Paragraphs">
<summary>
 Returns a list of paragraphs in the document
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.MarkdownDocument">
<summary>
 Return as markdown document, throwing away additional stuff
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.FormattedTips">
<summary>
 Formatted tool tips
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.Errors">
<summary>
 Errors
</summary>
</member>
<member name="P:FSharp.Literate.LiterateDocument.DefinedLinks">
<summary>
 Returns a dictionary containing explicitly defined links
</summary>
</member>
<member name="M:FSharp.Literate.LiterateDocument.With(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph}},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IDictionary{System.String,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}}},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.LiterateSource},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{FSharp.CodeFormat.SourceError}})">
<summary>
 Clone the document and change some of its properties
</summary>
</member>
<member name="T:FSharp.Literate.LiterateDocument">
<summary>
 Representation of a literate document - the representation of Paragraphs
 uses an F# discriminated union type and so is best used from F#.
</summary>
</member>
<member name="T:FSharp.Literate.LiterateSource">
<summary>
 Represents the source of a literate document. This is esither Markdown (as a `string`)
 or parsed F# script file consisting of snippets.
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.RawBlock">
<summary>
 Block simply emitted without any formatting equivalent to &lt;pre&gt; tag in html
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.LanguageTaggedCode">
<summary>
 Ordinary formatted code snippet in non-F# language (tagged with language code)
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.FormattedCode">
<summary>
 Ordinary formatted code snippet
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.LiterateCode">
<summary>
 Emebdded literate code snippet. Consists of source lines and options
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.ValueReference">
<summary>
 (*** include-value:foo ***) - Include the formatting of a specified value here
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.ItValueReference">
<summary>
 (*** include-it:foo ***) - Include &quot;it&quot; value from a snippet here 
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.OutputReference">
<summary>
 (*** include-output:foo ***) - Include output from a snippet here 
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph.CodeReference">
<summary>
 (*** include:foo ***) - Include formatted snippet from other part of the document here 
</summary>
</member>
<member name="T:FSharp.Literate.LiterateParagraph">
<summary>
 Extends `MarkdownParagrap` using the `MarkdownEmbedParagraphs` case with
 additional kinds of paragraphs that can appear in literate F# scripts
 (such as various special commands to embed output of a snippet etc.)
</summary>
</member>
<member name="P:FSharp.Literate.LiterateCodeOptions.Visibility">
<summary>
 Specifies the visibility of the snippet in the generated HTML
</summary>
</member>
<member name="P:FSharp.Literate.LiterateCodeOptions.OutputName">
<summary>
 Specifies the name of the output produced by this snippet
 Use the (*** define-output:foo ***) command to set this value
</summary>
</member>
<member name="P:FSharp.Literate.LiterateCodeOptions.Evaluate">
<summary>
 Specifies whether the snippet is evalauted while processing
 Use (*** do-not-eval ***) command to set this to `false`
</summary>
</member>
<member name="T:FSharp.Literate.LiterateCodeOptions">
<summary>
 Additional properties of a literate code snippet, embedded in a
 `LiterateParagraph.LiterateCode`. The properties specify how should
 a snippet be evaluated and formatted.
</summary>
</member>
<member name="T:FSharp.Literate.LiterateCodeVisibility">
<summary>
 Specifies visibility of a code snippet. This can be either ordinary
 visible code, hidden snippet or named snippet with captured output.
</summary>
</member>
<member name="F:FSharp.Literate.FsiEvaluator.valueTransformations">
<summary>
 Registered transformations for pretty printing values
 (the default formats value as a string and emits single CodeBlock)
</summary>
</member>
<member name="P:FSharp.Literate.FsiEvaluator.EvaluationFailed">
<summary>
 This event is fired whenever an evaluation of an expression fails
</summary>
</member>
<member name="M:FSharp.Literate.FsiEvaluator.RegisterTransformation(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Object,System.Type},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph}}})">
<summary>
 Register a function that formats (some) values that are produced by the evaluator.
 The specified function should return &apos;Some&apos; when it knows how to format a value
 and it should return formatted 
</summary>
</member>
<member name="M:FSharp.Literate.FsiEvaluator.FSharp-Literate-IFsiEvaluator-Format(FSharp.Literate.IFsiEvaluationResult,FSharp.Literate.FsiEmbedKind)">
<summary>
 Format a specified result or value 
</summary>
</member>
<member name="M:FSharp.Literate.FsiEvaluator.FSharp-Literate-IFsiEvaluator-Evaluate(System.String,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Evaluates the given text in an fsi session and returns
 an FsiEvaluationResult.

 If evaluated as an expression, Result should be set with the
 result of evaluating the text as an F# expression.
 If not, just the console output of the evaluation is captured and
 returned in Output.

 If file is set, the text will be evaluated as if it was present in the
 given script file - this is for correct usage of #I and #r with relative paths.
 Note however that __SOURCE_DIRECTORY___ does not currently pick this up.
</summary>
</member>
<member name="T:FSharp.Literate.FsiEvaluator">
<summary>
 A wrapper for F# interactive service that is used to evaluate inline snippets
</summary>
</member>
<member name="M:FSharp.Literate.FsiEvaluatorConfig.CreateNoOpFsiObject">
<summary>
 Creates a dummy `fsi` object that does not affect the behaviour of F# Interactive
 (and simply ignores all operations that are done on it). You can use this to 
 e.g. disable registered printers that would open new windows etc.
</summary>
</member>
<member name="T:FSharp.Literate.FsiEvaluatorConfig">
<summary>
 Provides configuration options for the `FsiEvaluator`
</summary>
</member>
<member name="T:FSharp.Literate.NoOpFsiObject">
<summary>
 Implements a simple &apos;fsi&apos; object to be passed to the FSI evaluator
</summary>
</member>
<member name="T:FSharp.Literate.NoOpFsiEventLoop">
<summary>
 Represents a simple (fake) event loop for the &apos;fsi&apos; object
</summary>
</member>
<member name="M:FSharp.Literate.IFsiEvaluator.Format(FSharp.Literate.IFsiEvaluationResult,FSharp.Literate.FsiEmbedKind)">
<summary>
 Called to format some part of evaluation result generated by FSI
</summary>
</member>
<member name="M:FSharp.Literate.IFsiEvaluator.Evaluate(System.String,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Called to evaluate a snippet 
</summary>
</member>
<member name="T:FSharp.Literate.IFsiEvaluator">
<summary>
 Represents an evaluator for F# snippets embedded in code
</summary>
</member>
<member name="T:FSharp.Literate.FsiEvaluationFailedInfo">
<summary>
 Record that is reported by the `EvaluationFailed` event when something
 goes wrong during evalutaiton of an expression
</summary>
</member>
<member name="T:FSharp.Literate.FsiEvaluationResult">
<summary>
 Represents the result of evaluating an F# snippet. This contains
 the generated console output together with a result and its static type.
</summary>
</member>
<member name="T:FSharp.Literate.IFsiEvaluationResult">
<summary>
 An interface that represents FSI evaluation result
 (we make this abstract so that evaluators can store other info)
</summary>
</member>
<member name="T:FSharp.Literate.FsiEmbedKind">
<summary>
 Represents a kind of thing that can be embedded 
</summary>
</member>
<member name="T:FSharp.Literate.ProcessingContext">
<summary>
 Specifies a context that is passed to functions that generate the output
</summary>
</member>
<member name="T:FSharp.Literate.GeneratorOutput">
<summary>
 Defines input type for output generator
</summary>
</member>
<member name="T:FSharp.Literate.OutputKind">
<summary>
 Defines the two possible output types from literate script: HTML and LaTeX.
</summary>
</member>
<member name="T:FSharp.Literate.CompilerContext">
<summary>
 Specifies a context that is passed to functions
 that need to use the F# compiler
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ProcessScriptFile(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.IFsiEvaluator},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Literate.ProcessingContext,Microsoft.FSharp.Core.FSharpFunc{FSharp.Literate.LiterateDocument,FSharp.Literate.LiterateDocument}}})">
<summary>
 Process F# Script file
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ProcessMarkdown(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Literate.ProcessingContext,Microsoft.FSharp.Core.FSharpFunc{FSharp.Literate.LiterateDocument,FSharp.Literate.LiterateDocument}}})">
<summary>
 Process Markdown document
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ProcessDocument(FSharp.Literate.LiterateDocument,System.String,Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}})">
<summary>
 Process the given literate document
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ProcessDirectory(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.OutputKind},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.IFsiEvaluator},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{FSharp.Literate.ProcessingContext,Microsoft.FSharp.Core.FSharpFunc{FSharp.Literate.LiterateDocument,FSharp.Literate.LiterateDocument}}})">
<summary>
 Process directory containing a mix of Markdown documents and F# Script files
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseScriptString``1(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.IFsiEvaluator})">
<summary>
 Parse F# Script file
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseScriptFile``1(System.String,Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.IFsiEvaluator})">
<summary>
 Parse F# Script file
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseMarkdownString``1(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.IFsiEvaluator})">
<summary>
 Parse Markdown document
</summary>
</member>
<member name="M:FSharp.Literate.Literate.ParseMarkdownFile``1(System.String,Microsoft.FSharp.Core.FSharpOption{FSharp.CodeFormat.CodeFormatAgent},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{FSharp.Literate.IFsiEvaluator})">
<summary>
 Parse Markdown document
</summary>
</member>
<member name="T:FSharp.Literate.Literate">
<summary>
 This type provides three simple methods for calling the literate programming tool.
 The `ProcessMarkdown` and `ProcessScriptFile` methods process a single Markdown document
 and F# script, respectively. The `ProcessDirectory` method handles an entire directory tree
 (looking for `*.fsx` and `*.md` files).
</summary>
</member>
<member name="T:FSharp.Literate.Matching">
<summary>
 Provides active patterns for extracting `LiterateParagraph` values from
 Markdown documents.
</summary>
</member>
<member name="M:FSharp.Literate.ParseScript.parseScriptFile(System.String,System.String,FSharp.Literate.CompilerContext)">
<summary>
 Parse script file with specified name and content
 and return `LiterateDocument` with the content
</summary>
</member>
<member name="M:FSharp.Literate.ParseScript.transformBlocks(System.Boolean,Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph},Microsoft.FSharp.Collections.FSharpList{System.Collections.Generic.IDictionary{System.String,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}}},Microsoft.FSharp.Collections.FSharpList{FSharp.Literate.CodeBlockUtils.Block})">
<summary>
 Transform list of code blocks (snippet/comment/command)
 into a formatted Markdown document, with link definitions
</summary>
</member>
<member name="T:FSharp.Literate.ParseScript">
<summary>
 Turns the content of `fsx` file into `LiterateDocument` that contains
 formatted F# snippets and parsed Markdown document. Handles commands such
 as `hide`, `define` and `include`.
</summary>
</member>
<member name="P:FSharp.Literate.CodeBlockUtils.parseScriptFile">
<summary>
 Parse F# script file into a sequence of snippets, comments and commands
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.collectSnippet(Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line},Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line})">
<summary>
 Collecting a block of F# snippet
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.collectComment(System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line})">
<summary>
 Waiting for the end of a comment      
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.|ConcatenatedComments|_|(FSharp.CodeFormat.Line)">
<summary>
 Succeeds when a line (list of tokens) contains only Comment 
 tokens and returns the text from the comment as a string
 (Comment may also be followed by Whitespace that is skipped)
</summary>
</member>
<member name="M:FSharp.Literate.CodeBlockUtils.trimBlanksAndReverse(System.Collections.Generic.IEnumerable{FSharp.CodeFormat.Line})">
<summary>
 Trim blank lines from both ends of a lines list &amp; reverse it (we accumulate 
 lines &amp; we want to remove all blanks before returning BlockSnippet)
</summary>
</member>
<member name="T:FSharp.Literate.CodeBlockUtils">
<summary>
 Parsing of F# Script files with Markdown commands. Given a parsed script file, we 
 split it into a sequence of comments, snippets and commands (comment starts with 
 `(**` and ending with `*)` are translated to Markdown, snippet is all other F# code 
 and command looks like `(*** key1:value, key2:value ***)` (and should be single line).
</summary>
</member>
<member name="M:FSharp.Literate.ParseMarkdown.parseMarkdown(System.String,System.String)">
<summary>
 Parse the specified Markdown document and return it
 as `LiterateDocument` (without processing code snippets)
</summary>
</member>
<member name="T:FSharp.Literate.Transformations.EvalKey">
<summary>
 Represents key in a dictionary with evaluation results
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceLiterateParagraphs(FSharp.Literate.ProcessingContext,FSharp.Literate.LiterateDocument)">
<summary>
 Replace all special &apos;LiterateParagraph&apos; elements with ordinary HTML/Latex
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceSpecialCodes(FSharp.Literate.ProcessingContext,System.Collections.Generic.IDictionary{Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line},System.String},FSharp.Markdown.MarkdownParagraph},FSharp.Markdown.MarkdownParagraph)">
<summary>
 Replace all special &apos;LiterateParagraph&apos; elements recursively using the given lookup dictionary
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.collectCodes(FSharp.Markdown.MarkdownParagraph)">
<summary>
 Collect all code snippets in the document (so that we can format all of them)
 The resulting dictionary has Choice as the key, so that we can distinguish 
 between moved snippets and ordinary snippets
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.evaluateCodeSnippets(FSharp.Literate.CompilerContext,FSharp.Literate.LiterateDocument)">
<summary>
 Transform the specified literate document &amp; evaluate all F# snippets
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.evalAllSnippets(FSharp.Literate.IFsiEvaluator,FSharp.Literate.LiterateDocument)">
<summary>
 Given an evaluator and document, evaluate all code snippets and return a map with
 their results - the key is `ValueRef(name)` for all value references and 
 `OutputRef(name)` for all references to the snippet console output
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.evalBlocks(FSharp.Literate.IFsiEvaluator,System.String,Microsoft.FSharp.Collections.FSharpList{System.Tuple{FSharp.Literate.Transformations.EvalKey,FSharp.Literate.IFsiEvaluationResult}},Microsoft.FSharp.Collections.FSharpList{FSharp.Markdown.MarkdownParagraph})">
<summary>
 Evaluate all the snippets in a literate document, returning the results.
 The result is a map of string * bool to FsiEvaluationResult. The bool indicates
 whether the result is a top level variable (i.e. include-value) or a reference to 
 some output (i.e. define-output and include-output). This just to put each of those
 names in a separate scope.
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.unparse(Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line})">
<summary>
 Unparse a Line list to a string - for evaluation by fsi.
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.generateReferences(FSharp.Literate.LiterateDocument)">
<summary>
 Turn all indirect links into a references 
 and add paragraph to the document
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.generateRefParagraphs``1(System.Collections.Generic.IDictionary{``0,System.Tuple{System.String,Microsoft.FSharp.Core.FSharpOption{System.String}}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Given all links defined in the Markdown document and a list of all links
 that are accessed somewhere from the document, generate References paragraph
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceReferences(System.Collections.Generic.IDictionary{System.String,System.Int32})">
<summary>
 Given Markdown document, add a number using the given index to all indirect 
 references. For example, [article][ref] becomes [article][ref] [1](#rfxyz)
</summary>
</member>
<member name="P:FSharp.Literate.Transformations.collectReferences">
<summary>
 Given Markdown document, get the keys of all IndirectLinks 
 (to be used when generating paragraph with all references)
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.formatCodeSnippets(System.String,FSharp.Literate.CompilerContext,FSharp.Literate.LiterateDocument)">
<summary>
 Walk over literate document and replace F# code snippets with 
 their formatted representation (of `LiterateParagraph` type)
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.replaceCodeSnippets(System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.FSharp.Collections.FSharpList{FSharp.CodeFormat.Line}},FSharp.Markdown.MarkdownParagraph)">
<summary>
 Replace CodeBlock elements with formatted HTML that was processed by the F# snippets tool
 (The dictionary argument is a map from original code snippets to formatted HTML snippets.)
</summary>
</member>
<member name="M:FSharp.Literate.Transformations.collectCodeSnippets(FSharp.Markdown.MarkdownParagraph)">
<summary>
 Iterate over Markdown document and extract all F# code snippets that we want
 to colorize. We skip snippets that specify non-fsharp langauge e.g. [lang=csharp].
</summary>
</member>
<member name="T:FSharp.Literate.Transformations">
<summary>
 [omit]
</summary>
</member>
<member name="T:FSharp.Literate.Templating">
<summary>
 [omit]
</summary>
</member>
<member name="M:FSharp.Literate.Formatting.getSourceDocument(FSharp.Literate.LiterateDocument)">
<summary>
 Given literate document, get a new MarkdownDocument that represents the
 entire source code of the specified document (with possible `fsx` formatting)
</summary>
</member>
<member name="M:FSharp.Literate.Formatting.findHeadings(System.Collections.Generic.IEnumerable{FSharp.Markdown.MarkdownParagraph},System.Boolean,FSharp.Literate.OutputKind)">
<summary>
 Try find first-level heading in the paragraph collection
</summary>
</member>
<member name="M:FSharp.Literate.Formatting.format(FSharp.Markdown.MarkdownDocument,System.Boolean,FSharp.Literate.OutputKind)">
<summary>
 Format document with the specified output kind
</summary>
</member>
<member name="T:FSharp.Literate.Formatting">
<summary>
 [omit]
</summary>
</member>
</members>
</doc>
